// MACHINE GENERATED BY 'go generate' COMMAND; DO NOT EDIT

package mssys

import "unsafe"
import "syscall"

var _ unsafe.Pointer

var (
	modntdll    = syscall.NewLazyDLL("ntdll.dll")
	modkernel32 = syscall.NewLazyDLL("kernel32.dll")

	procNtQueryInformationThread = modntdll.NewProc("NtQueryInformationThread")
	procGetThreadContext         = modkernel32.NewProc("GetThreadContext")
	procSetThreadContext         = modkernel32.NewProc("SetThreadContext")
	procSuspendThread            = modkernel32.NewProc("SuspendThread")
	procResumeThread             = modkernel32.NewProc("ResumeThread")
	procContinueDebugEvent       = modkernel32.NewProc("ContinueDebugEvent")
	procWriteProcessMemory       = modkernel32.NewProc("WriteProcessMemory")
	procReadProcessMemory        = modkernel32.NewProc("ReadProcessMemory")
	procDebugBreakProcess        = modkernel32.NewProc("DebugBreakProcess")
	procWaitForDebugEvent        = modkernel32.NewProc("WaitForDebugEvent")
)

func NtQueryInformationThread(threadHandle syscall.Handle, infoclass int32, info uintptr, infolen uint32, retlen *uint32) (status NTSTATUS) {
	r0, _, _ := syscall.Syscall6(procNtQueryInformationThread.Addr(), 5, uintptr(threadHandle), uintptr(infoclass), uintptr(info), uintptr(infolen), uintptr(unsafe.Pointer(retlen)), 0)
	status = NTSTATUS(r0)
	return
}

func GetThreadContext(thread syscall.Handle, context *CONTEXT) (err error) {
	r1, _, e1 := syscall.Syscall(procGetThreadContext.Addr(), 2, uintptr(thread), uintptr(unsafe.Pointer(context)), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = error(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func SetThreadContext(thread syscall.Handle, context *CONTEXT) (err error) {
	r1, _, e1 := syscall.Syscall(procSetThreadContext.Addr(), 2, uintptr(thread), uintptr(unsafe.Pointer(context)), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = error(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func SuspendThread(threadid syscall.Handle) (prevsuspcount uint32, err error) {
	r0, _, e1 := syscall.Syscall(procSuspendThread.Addr(), 1, uintptr(threadid), 0, 0)
	prevsuspcount = uint32(r0)
	if prevsuspcount == 0xffffffff {
		if e1 != 0 {
			err = error(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func ResumeThread(threadid syscall.Handle) (prevsuspcount uint32, err error) {
	r0, _, e1 := syscall.Syscall(procResumeThread.Addr(), 1, uintptr(threadid), 0, 0)
	prevsuspcount = uint32(r0)
	if prevsuspcount == 0xffffffff {
		if e1 != 0 {
			err = error(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func ContinueDebugEvent(processid uint32, threadid uint32, continuestatus uint32) (err error) {
	r1, _, e1 := syscall.Syscall(procContinueDebugEvent.Addr(), 3, uintptr(processid), uintptr(threadid), uintptr(continuestatus))
	if r1 == 0 {
		if e1 != 0 {
			err = error(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func WriteProcessMemory(process syscall.Handle, baseaddr uintptr, buffer *byte, size uintptr, byteswritten *uintptr) (err error) {
	r1, _, e1 := syscall.Syscall6(procWriteProcessMemory.Addr(), 5, uintptr(process), uintptr(baseaddr), uintptr(unsafe.Pointer(buffer)), uintptr(size), uintptr(unsafe.Pointer(byteswritten)), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = error(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func ReadProcessMemory(process syscall.Handle, baseaddr uintptr, buffer *byte, size uintptr, bytesread *uintptr) (err error) {
	r1, _, e1 := syscall.Syscall6(procReadProcessMemory.Addr(), 5, uintptr(process), uintptr(baseaddr), uintptr(unsafe.Pointer(buffer)), uintptr(size), uintptr(unsafe.Pointer(bytesread)), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = error(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func DebugBreakProcess(process syscall.Handle) (err error) {
	r1, _, e1 := syscall.Syscall(procDebugBreakProcess.Addr(), 1, uintptr(process), 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = error(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func WaitForDebugEvent(debugevent *DEBUG_EVENT, milliseconds uint32) (err error) {
	r1, _, e1 := syscall.Syscall(procWaitForDebugEvent.Addr(), 2, uintptr(unsafe.Pointer(debugevent)), uintptr(milliseconds), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = error(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}
